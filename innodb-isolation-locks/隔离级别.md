## 从隔离级别说起
隔离级别是为了解决特定问题而提出的方案，不同隔离级别的实现是通过不同的上锁方式，下面一个一个来看不同的隔离级别分别存在什么问题，他们又各自解决了什么问题。

![iso](static/2020-10/iso.png)
google-adsense

---

## READ-UNCOMMIED

一个事务可以读到另一个事务还未提交的数据、也就是说有“脏读”的问题、这种问题通常来讲是不可接受的。
```sql

-- 隔离级别为 
show global variables like '%iso%';
+-----------------------+------------------+
| Variable_name         | Value            |
+-----------------------+------------------+
| transaction_isolation | READ-UNCOMMITTED |
+-----------------------+------------------+
1 row in set (0.00 sec)

-- 建表
create table t(id int primary key,v int);
insert into t(id,v) values(1,100);

-- READ-UNCOMMITTED 可以读到未提交的数据
+--------------------------------------------+---------------------------------------------+
|             -- session A  --               |             -- session B  --                |
|--------------------------------------------+---------------------------------------------|
|begin;                                      |                                             |
|select id,v from t where id =1; // 1,100    |                                             |
|                                            |begin;                                       |
|                                            |update t set v = 99 where id =1;             |
|select id,v from t where id =1; // 1,99     |                                             | // 读到了 session B 中未提交的数据
|                                            |rollback;                                    |
|select id,v from t where id =1; // 1,100    |                                             |
+--------------------------------------------+---------------------------------------------+
```

---

## READ-COMMITTED

首先 READ-COMMITTED 级别修复了 READ-UNCOMMITTED 级别脏读的问题。
```sql
-- 隔离级别为 
show global variables like '%iso%';
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
1 row in set (0.00 sec)

select * from t;                                                                          
+----+------+
| id | v    |
+----+------+
|  1 |  100 |
+----+------+
1 row in set (0.00 sec)

+--------------------------------------------+---------------------------------------------+
|             -- session A  --               |             -- session B  --                |
|--------------------------------------------+---------------------------------------------|
|begin;                                      |                                             |
|select id,v from t where id =1; // 1,100    |                                             |
|                                            |begin;                                       |
|                                            |update t set v = 99 where id =1;             |
|select id,v from t where id =1; // 1,100    |                                             | // 读不到了 session B 中未提交的数据
|                                            |commit;                                      |
|select id,v from t where id =1; // 1,99     |                                             | // 读到了 session B 中已提交的数据
+--------------------------------------------+---------------------------------------------+
```

那么 READ-COMMITTED 级别自己有什么问题呢？由上面的例子可以看到事务 A 第一次和第三次读到的数据不一样，就个就叫出现了`不可重复读(幻读是不可重复读的一个特殊情况)` 的问题。

---

## REPEATABLE-READ

首先 REPEATABLE-READ 级别修复了 READ-COMMITTED 级别不可重复读的问题，由于幻读是不可重复读的一个特殊例子，所以幻读事实上也解决了。

```sql
-- 查看隔离级别
show global variables like '%iso%';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.01 sec)

-- 
select * from t;                                                                          
+----+------+
| id | v    |
+----+------+
|  1 |  100 |
+----+------+
1 row in set (0.00 sec)

-- 不加上锁语句，都是走 MVCC 自然是可重复读的
+--------------------------------------------+---------------------------------------------+
|             -- session A  --               |             -- session B  --                |
|--------------------------------------------+---------------------------------------------|
|begin;                                      |                                             |
|select id,v from t where id =1; // 1,100    |                                             |
|                                            |begin;                                       |
|                                            |update t set v = 99 where id =1;             |
|select id,v from t where id =1; // 1,100    |                                             | 
|                                            |commit;                                      |
|select id,v from t where id =1; // 1,100    |                                             | // 可以看到读出来的数据不会变
+--------------------------------------------+---------------------------------------------+

+--------------------------------------------------+---------------------------------------------+
|                   -- session A  --               |             -- session B  --                |
|--------------------------------------------------+---------------------------------------------|
|begin;                                            |                                             |
|select id,v from t where id <=7; // 1,100         |                                             |
|                                                  |begin;                                       |
|                                                  |insert into t(id,v) values(3,300);           |
|select id,v from t where id <=7; // 1,100         |                                             | 
|                                                  |commit;                                      |
|select id,v from t where id <=7; // 1,100         |                                             | // 可以看到读出来的数据不会变
+--------------------------------------------------+---------------------------------------------+

select * from t where id <=7;
+----+------+
| id | v    |
+----+------+
|  1 |  100 |
|  3 |  300 |
+----+------+
2 rows in set (0.00 sec)

```

在 REPEATABLE-READ 的级别下通过锁定区间来解决`幻读`问题，对于当前读来说，REPEATABLE-READ 为了达到多次读取结果一致的效果，它直接把它要用到的区间给排他锁定，
这样其它事务就无法插入了。

```sql
show global variables like '%iso%';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)

select * from t;                                                                          
+----+------+
| id | v    |
+----+------+
|  1 |  100 |
|  3 |  300 |
+----+------+
2 rows in set (0.00 sec)

+---------------------------------------------------------+---------------------------------------------+
|                   -- session A  --                      |             -- session B  --                |
|---------------------------------------------------------+---------------------------------------------|
|begin;                                                   |                                             |
|select id,v from t where id <=7 for share; // 1,100 3,300|                                             |
|                                                         |begin;                                       |
|                                                         |insert into t(id,v) values(2,200);           |
|select id,v from t where id <=7 for share; // 1,100 3,300|-- [-∞,+∞] 整个区间都被锁住了，所以 insert 被阻塞 | 
|commit                                                   |-- A commit 后, B 才能 commit                 |
|select id,v from t where id <=7 for share; // 1,100 3,300|commit;                                      | // 可以看到读出来的数据不会变
+---------------------------------------------------------+---------------------------------------------+
```

---

## SERIALIZABLE
REPEATABLE-READ 虽然可以保证事务内的一致性读，它就问题就在于快照的数据并不一定是这行数据的最新版本；如果想每一次读写操作的都是最新版的数据的话，那就要求所有的读写操作
都要上锁。也就是说读写之间串行化了，这个隔离级别就是 SERIALIZABLE。

```sql
show global variables like '%iso%';
+-----------------------+--------------+
| Variable_name         | Value        |
+-----------------------+--------------+
| transaction_isolation | SERIALIZABLE |
+-----------------------+--------------+
1 row in set (0.01 sec)

select id,v from t where id <=7;                                                          
+----+------+
| id | v    |
+----+------+
|  1 |  100 |
|  3 |  300 |
+----+------+
2 rows in set (0.00 sec)

+---------------------------------------------------------+---------------------------------------------+
|                   -- session A  --                      |             -- session B  --                |
|---------------------------------------------------------+---------------------------------------------|
|begin;                                                   |                                             |
|select id,v from t where id <=7 ; // 1,100 3,300         |                                             |
|                                                         |begin;                                       |
|                                                         |update t set v = 100 where id =1;            |
|select id,v from t where id <=7 ; // 1,100 3,300         |--  SERIALIZABLE 已经没有 MVCC 所以这个也会被阻塞| 
|commit                                                   |-- A commit 后, B 才能 commit                 |
|select id,v from t where id <=7 ; // 1,100 3,300         |commit;                                      | // 可以看到读出来的数据不会变
+---------------------------------------------------------+---------------------------------------------+
```

---
   





