[TOC]

## View是如何和与其它类协作的
   **1、** 在 View 这个类中实现了请求处理这个流程中所有可以重用，可共用的部分；View 的子类实现具体逻辑代码，View 中会调用子类的代码来完成请求处理这整个流程。

   |**步骤**|**实现的类**|**备注**|
   |-------|-----------|-------|
   |`__init__`| View     |创建 View(View子类)的实例|
   |`setup`   | View     |在 View实例上设置好属性|
   |`dispatch`| View     |根据 request.method 来选择调用子类的哪个方法，返回调用完成之后的返回值|

   ---

   **2、** 综上 所有 View 的子类只要把业务逻辑实现就好，View 在处理请求时会调用相关方法的

   ---

## 例子
   
   **1、** 业务代码
   ```python
   class HelloView(View):
       noter = noter.getChild("HelloView")
   
       def get(self, request):
           noter = self.noter.getChild("get")
           noter.debug("start view function get")
           return JsonResponse({'hello': 'world'})
   
   ```
   **2、** 运行日志
   ```bash
   2020-01-10 07:54:06,534 - DEBUG - django.notes.HelloView.as_view.view - 103 line - inner view function been called arsg is () kwargs is {} cls is <class 'apps.foo.views.HelloView'>
   2020-01-10 07:54:06,534 - DEBUG - django.notes.HelloView.as_view.view - 103 line - inner view function been called arsg is () kwargs is {} cls is <class 'apps.foo.views.HelloView'>
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.__init__ - 66 line - kwargs is {}
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.__init__ - 66 line - kwargs is {}
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.setup - 141 line - request.path is '/foo/' args is () kwargs = {}
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.setup - 141 line - request.path is '/foo/' args is () kwargs = {}
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.dispatch - 151 line - args is () kwargs is {}
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.dispatch - 151 line - args is () kwargs is {}
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.dispatch - 154 line - allocat handler get
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.dispatch - 154 line - allocat handler get
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.dispatch - 159 line - execute handler
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.dispatch - 159 line - execute handler
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.get - 16 line - start view function get
   2020-01-10 07:54:06,535 - DEBUG - django.notes.HelloView.get - 16 line - start view function get
   2020-01-10 07:54:06,536 - INFO - django.server - 157 line - "GET /foo/ HTTP/1.1" 200 18
   ```

   **3、** dispatche 方法的关键部分
   ```python
   def dispatch(self, request, *args, **kwargs):
       # 检查 http 请求方法是否合法
       if request.method.lower() in self.http_method_names:
           # 如果类似于 get post put .... 就直接就直接去子类中找对应的方法
           handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
       else:
           handler = self.http_method_not_allowed
       
       # 调用子类的处理逻辑，并返回子类处理的结果
       return handler(request, *args, **kwargs)
   ```

   ---

## 与TemplateView如何协作
   **1、** 所有与模板渲染相关的能用逻辑被抽象到了 TemplateResponseMixin 中
   ```python
   class TemplateResponseMixin:
       """
       渲染模板到 HttpResponse
       """
       template_name = None
       template_engine = None
       response_class = TemplateResponse
       content_type = None
   
       noter = noter.getChild("TemplateResponseMixin")
   
       def render_to_response(self, context, **response_kwargs):
           # 设置 content_type
           noter.debug(f"set content_type to {self.content_type}")
           response_kwargs.setdefault('content_type', self.content_type)
   
           # 返回响应
           noter.debug(f"new response instance '{self.response_class}'' and return it")
           return self.response_class(
               request=self.request,  # setup 执行之后就有了 self.request
               template=self.get_template_names(),  # 自己有定义了这个方法
               context=context,      # content 来自动发函数参数
               using=self.template_engine,  # 自己有定义
               **response_kwargs     # 其它参数
           )
   
       def get_template_names(self):
           noter = self.noter.getChild("get_template_names")
   
           # 当 self.template_name 是空的时候会报错
           if self.template_name is None:
               raise ImproperlyConfigured(
                   "TemplateResponseMixin requires either a definition of "
                   "'template_name' or an implementation of 'get_template_names()'")
           else:
               noter.debug(f"using template '{self.template_name}' ")
               # 返回 self.template_name 组成的列表
               return [self.template_name]
   ```
   **2、** 直接 mixin 
   ```python
   class TemplateView(TemplateResponseMixin, ContextMixin, View):
       """
       Render a template. Pass keyword arguments from the URLconf to the context.
       """
       noter = noter.getChild("TemplateView")
   
       def get(self, request, *args, **kwargs):
           noter = self.noter.getChild("get")
   
           # 执行 get_context_data 方法
           noter.debug("call get_context_data function")
           context = self.get_context_data(**kwargs)
           noter.debug("call render_to_response function")
           # 返回响应
           return self.render_to_response(context)
   ```
   **3、** 一个请求处理流程上的日志如下
   ```bash
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.as_view.view - 103 line - inner view function been called arsg is () kwargs is {} cls is <class 'apps.foo.views.HelloTemplateView'>
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.as_view.view - 103 line - inner view function been called arsg is () kwargs is {} cls is <class 'apps.foo.views.HelloTemplateView'>
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.__init__ - 66 line - kwargs is {}
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.__init__ - 66 line - kwargs is {}
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.setup - 141 line - request.path is '/foo/template' args is () kwargs = {}
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.setup - 141 line - request.path is '/foo/template' args is () kwargs = {}
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.dispatch - 151 line - args is () kwargs is {}
   2020-01-10 08:19:23,562 - DEBUG - django.notes.HelloTemplateView.dispatch - 151 line - args is () kwargs is {}
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.dispatch - 154 line - allocat handler get
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.dispatch - 154 line - allocat handler get
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.dispatch - 159 line - execute handler
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.dispatch - 159 line - execute handler
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.get - 240 line - call get_context_data function
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.get - 240 line - call get_context_data function
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.get_context_data - 43 line - kwargs is {}
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.get_context_data - 43 line - kwargs is {}
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.get - 242 line - call render_to_response function
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.get - 242 line - call render_to_response function
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.render_to_response - 199 line - set content_type to None
   2020-01-10 08:19:23,563 - DEBUG - django.notes.HelloTemplateView.render_to_response - 199 line - set content_type to None
   2020-01-10 08:19:23,564 - DEBUG - django.notes.HelloTemplateView.render_to_response - 203 line - new response instance '<class 'django.template.response.TemplateResponse'>' and return it
   2020-01-10 08:19:23,564 - DEBUG - django.notes.HelloTemplateView.render_to_response - 203 line - new response instance '<class 'django.template.response.TemplateResponse'>' and return it
   2020-01-10 08:19:23,565 - INFO - django.server - 157 line - "GET /foo/template HTTP/1.1" 200 131
   ```

   ---

## 与RedirectView如何协作
   ```python
   class RedirectView(View):
       """Provide a redirect on any GET request."""
       permanent = False
       url = None
       pattern_name = None
       query_string = False
   
       def get_redirect_url(self, *args, **kwargs):
           """
           Return the URL redirect to. Keyword arguments from the URL pattern
           match generating the redirect request are provided as kwargs to this
           method.
           """
           if self.url:
               url = self.url % kwargs
           elif self.pattern_name:
               url = reverse(self.pattern_name, args=args, kwargs=kwargs)
           else:
               return None
   
           args = self.request.META.get('QUERY_STRING', '')
           if args and self.query_string:
               url = "%s?%s" % (url, args)
           return url
   
       def get(self, request, *args, **kwargs):
           url = self.get_redirect_url(*args, **kwargs)
           if url:
               if self.permanent:
                   return HttpResponsePermanentRedirect(url)
               else:
                   return HttpResponseRedirect(url)
           else:
               logger.warning(
                   'Gone: %s', request.path,
                   extra={'status_code': 410, 'request': request}
               )
               return HttpResponseGone()
   
   ```


